"""
Script for parsing elevation data and generating output for a give
lattitude/longitude

Supported input:
- STRM DEM (.hgt)

Supported output:
- Image (.jpg)
- Model (.ply, .scad)

Elevation data can be downloaded from:
http://www.viewfinderpanoramas.org/dem3.html
"""
from __future__ import division

from struct import unpack,calcsize
import Image
import numpy
import math
import csv
from latlon import *

debug_enabled = True

def dbg(msg):
	if debug_enabled:
		print "DEBUG:", msg

def make_scad(data, outputfile, scale_x, scale_y, scale_z):
	datafile = outputfile + ".dat"
	fd = open(datafile, "w")
	for y in range(data.shape[1]):
		for x in range(data.shape[0]):
			fd.write("%f " % (data[x,y]))
		fd.write("\n")
	fd.close()
	print "Saved scad data %s" % (datafile)

	fd = open(outputfile, "w")
	fd.write("//\n")
	fd.write("// Generated by generate.py\n")
	fd.write("//\n")
	fd.write("union() { \n")
	fd.write("   scale([%f, %f, %f])\n" % (scale_x, scale_y, scale_z))
	fd.write("      surface(file = \"%s\", center = true, convexity = 5);\n" % (os.path.basename(datafile)))
	fd.write("};\n")
	fd.close()
	print "Saved scad %s" % (outputfile)

def make_jpg(data, outfile):
	ppix = numpy.array(data)
	im = Image.fromarray(ppix)

	#imrgb = Image.merge('RGB', (im,im,im))
	imrgb = im.convert("RGB")

	imrgb.save(outfile)
	print "Saved JPG %s (Size=%dx%d)" % (outfile, data.shape[0], data.shape[1])

def readhgt(filename):
	dbg("Opening %s" % (filename))
	f = open(filename, "rb")
	hgt_string = f.read()

	tilesize = int(math.sqrt(len(hgt_string)/2))
	if tilesize == 1201:
		resolution = 3
	elif tilesize == 3601:
		resolution = 1
	else:
		raise Exception('Error: Can only support 3" and 1" data')

	dbg(" Tile size %d Resolution %d\"" % (tilesize, resolution))

	hgt_2darray = numpy.flipud(((numpy.fromstring(string=hgt_string, dtype='int16')).byteswap()).reshape(tilesize,tilesize))
	return tilesize, hgt_2darray

def gethgt(hgt_2darray, lat, lon):
	try:
		data = hgt_2darray[lat, lon]
		return data
	except:
		print "No height for %d,%d" % (lat, lon)
		return 0


def generate(latlon, distance, target_size, minimum_height, remove_base_ele, input, outfile):
	filename = latlon.filename(input)
	if filename is None:
		# Unable to find height data
		return

	tilesize, hgt_2darray = readhgt(filename)

	lat = int(latlon.lat_val(min_only=True) * tilesize)
	lon = int(latlon.lon_val(min_only=True) * tilesize)

	dbg("  Height for loaded file: min=%f, max=%f" % (hgt_2darray.min(), hgt_2darray.max()))

	lon_length = calc_lon_len(latlon.get_lat())
	lat_length = calc_lat_len(latlon.get_lon())

	elements_to_use_x = distance / (lat_length / tilesize)
	elements_to_use_y = distance / (lon_length / tilesize)
	size_x = int(elements_to_use_x)
	size_y = int(elements_to_use_y)
	dbg("   Length of 1\" longitude=%f meter. Corresponds to %d array elements" % (lon_length, size_x))
	dbg("   Length of 1\" lattitude=%f meter. Corresponds to %d array elements" % (lat_length, size_y))

	data = numpy.zeros(size_x*size_y, dtype=numpy.float64).reshape((size_x, size_y))
	for y in xrange(size_y):
		for x in xrange(size_x):
			ylon = (lon - size_y / 2) + y
			xlat = (lat + size_x / 2) - x
			zzz = gethgt(hgt_2darray, xlat, ylon)

			data[x,y] = zzz

	zmin = data.min()
	zmax = data.max()
	dbg("  Height for selected data: min=%f max=%f" % (zmin, zmax))

	if remove_base_ele:
		print "Removing base ele of %f" % (zmin)
		data = data - zmin

	# Scale data from 0.0 to 1.0
	data = data / data.max()

	# Calculate target height
	target_height = target_size / distance * zmax

	# Calculate model scale
	the_scale = distance / (target_size / 1000)

	print "Model scale data:"
	print " Model length=%.1f mm. (Real life=%d meter)" % (target_size, distance)
	print " Model height=%.1f mm (Real life=%d meter)" % (target_height, zmax)
	print " Scale=1:%d" % (the_scale)

	make_jpg(data*255, outfile+".jpg")

	# Scale data to target height
	data = data * target_height

	if data.min() < minimum_height:
		print " Adding minimum height of %f" % (minimum_height)
		data = data + minimum_height

	dbg("  Height output data: min=%f max=%f" % (data.min(), data.max()))

	xscale = target_size / size_x
	sx = xscale
	sy = xscale * (size_x / size_y)
	sz = 1
	dbg("   Scale x=%f y=%f z=%f" % (sx, sy, sz))
	make_scad(data, outfile+".scad", sx, sy, sz)

def read_places_from_csv(placesfile):
	places = {}
	csvfile = open(placesfile, "r")
	reader = csv.reader(csvfile, delimiter=";")
	for row in reader:
		# Strip away whitespace
		row = [item.strip() for item in row]
		try:
			key = row[0]
			name = row[1]
			latn = row[2]
			lat = [int(item) for item in row[3:6]]
			lone = row[6]
			lon = [int(item) for item in row[7:10]]
			radius = int(row[10])
			#print key, name, lat, lon, radius
			places[key] = (name, LatLon(lat, lon), radius)
		except:
			print "Invalid line", row
			#raise
	print "Read %d places from %s" %(len(places),  placesfile)

	return places


if __name__ == "__main__":
	target = "HUR"

	places = read_places_from_csv("places.csv")
	name, latlon, radius = places[target]

	# Target sizes (in mm)
	target_size = 100
	min_height = 0.6
	remove_base_ele = True

	print "== Generating %s ==" % (name)
	generate(latlon, radius, target_size, min_height, remove_base_ele, "input/", "output/heightmap")
